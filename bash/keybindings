#!/usr/bin/env bash
#
# vim wrapper for bash readline

# This is ridiculous! seriously.
# Reasons why I should do this:
# 1) I want to have customized prompt
# 2) I want cuts and paste to save to/from system's clipboard
# 3) I want to play saved macro normally (not like with readline)
# 4) I want to have text objects (targets)
# 5) I want to have substitute using regex
# 6) I want to have visual selection mode
# 7) I want to have linenumbers (or fcedit)

REGISTER_PLUS="$(xclip -selection clipboard -out)"


function main() {
  shopt -oq vi && {
    __set_keybindings
  };
}

function __set_keybindings() {
  declare -A vim_func=(
   [dd]='_vim_delete_to'
   [dl]='_vim_delete_to' # aliased x
   [dh]='_vim_delete_to' # aliased X
   [p]='_vim_put'
   [P]='_vim_put P'
   [x]='_vim_delete'
   [X]='_vim_delete X'
   [r]='_vim_change_char'
   [h]='_vim_backward_char'
   [l]='_vim_forward_char'
   [1]='_vim_arg_digit 1'
   [2]='_vim_arg_digit 2'
   [3]='_vim_arg_digit 3'
   [4]='_vim_arg_digit 4'
   [5]='_vim_arg_digit 5'
   [6]='_vim_arg_digit 6'
   [7]='_vim_arg_digit 7'
   [8]='_vim_arg_digit 8'
   [9]='_vim_arg_digit 9'
   [0]='_vim_beginning_of_line'
   [$]='_vim_end_of_line'
   [m]='_vim_set_mark'
   ['`']='_vim_goto_mark'
   [q]='_vim_record_macro'
   [.]='_vim_play_last_macro'
   [j]='_vim_accept_line'
   [j]='_vim_accept_line'
  );

  # insert mode
  bind -m vi-insert -x '"kj":"_vim_movement_mode"'

  # shellcheck disable=SC2140
  for key in ${!vim_func[*]}; do
    bind -m vi-command -x \""$key\"":\ \""${vim_func[$key]}"\"
  done
}


__set_keybindings

# ------------------------------------------------------------------
# helper functions
# ------------------------------------------------------------------
#
# repeat 'expr'  by 'count' and print the concatenated results
# if there's no [count] input, only print [expr] once.
# usage: repeat [expr] [count]
function repeat() {
  for (( i = 0; i < ${2:-1}; i++ )); do
    printf %s "$1"
  done
}

# return the length of given string.
# usage: len [string]
function len() {
  echo -n "$1" | wc -c
}

# return given string in uppercase format.
# usage: uppercase [string]
function uppercase() {
  echo "${1^^}"
}

# return given string in lowercase format.
# usage: lowercase [string]
function lowercase() {
  echo "${1,,}"
}

function _bring_back_readline_color() {
  # shellcheck disable=SC2154
  echo -ne "${pink}"
}

# reprint readline while waiting for input (buggy)
# Issues: doesn't do well in wrapped and/or multiple lines.
function _vim_prompt() {
  command tput civis # hide cursor
  # printf "%b" "\\033[2K"
  builtin read -r -n "${2:-1}" -p "$(printf "%s\\r" "${1:-prompt:}")" VIM_PROMPT
  printf "%b" "\\033[2K"
  command tput cvvis; # show cursor
}

# initialize variables for the current scope
function init_variable() {
  # shellcheck disable=SC2034,SC2154
  {
  point_to_last="${READLINE_LINE:$READLINE_POINT}"
  after_point_to_last="${READLINE_LINE:$READLINE_POINT+1}"
  first_to_point="${READLINE_LINE:0:$READLINE_POINT+1}"
  first_before_point="${READLINE_LINE:0:$READLINE_POINT}"
  point_char="${READLINE_LINE:$READLINE_POINT:1}"
  fake_cursor="[48;5;209m${black}${point_char}[0m${pink}"
  readline=$first_before_point$fake_cursor$after_point_to_last;
  }
}

# send key to readline
function send_key() {
  [ -z "$TMUX" ] \
    && perl -le 'require "sys/ioctl.ph";
    ioctl(STDIN, &TIOCSTI, $_) or die "$!\n" for split "", join " ", @ARGV' "$@"
  command tmux send-keys -l "$@"
}

# ------------------------------------------------------------------
# vim_readline functions
# ------------------------------------------------------------------

function _vim_record_macro() {
  init_variable
  declare -g LAST_MACRO
  until [[ "$VIM_PROMPT" == 'q' ]]; do
    _vim_prompt "${red}rec:${pink} ${readline[*]}"
    LAST_MACRO+="${VIM_PROMPT}"
  done
  LAST_MACRO="${LAST_MACRO:0:-1}"
  _bring_back_readline_color
}

# more like dot command.
function _vim_play_last_macro() {
   send_key "$LAST_MACRO"
}

function _vim_command_() {
  init_variable
}

# bind -m vi-command -r kj bind -m vi-insert -x '"kj": "_vim_movement_mode"'
function _vim_movement_mode() {
 tmux send-keys ""
 _bring_back_readline_color
}

function _vim_insertion_move() {
  local
}

# accept the line regardless of where the cursor is.
bind -m vi-command -x '"j": "_vim_accept_line"'
function _vim_accept_line() {
  send_key ''
  # clear markers
  unset -v VIM_MARKERS
  _bring_back_readline_color
 }

# move to the start of current line (0).
function _vim_beginning_of_line() {
  READLINE_POINT=0
  _bring_back_readline_color
}

# move to the end of the line ($).
function _vim_end_of_line() {
  READLINE_POINT=$(($(len "$READLINE_LINE") - 1))
  _bring_back_readline_color
}

# move forward one character (l).
function _vim_forward_char() {
  [[ $# -ne 0 ]] && READLINE_POINT=$((READLINE_POINT + $1)) \
    || READLINE_POINT=$((READLINE_POINT + 1))
  _bring_back_readline_color
}

# move backward one character (h)
function _vim_backward_char() {
  [[ $# -ne 0 ]] && READLINE_POINT=$((READLINE_POINT - $1)) \
    || READLINE_POINT=$((READLINE_POINT - 1))
  _bring_back_readline_color

}

# ------------------------------------------------------------------
# word motion (W,w,e,E,b,B,gE,ge)
# ------------------------------------------------------------------

# move to the start of next word
function _vim_next_word() {
# A word consists of a sequence of letters, digits and underscores, or a
# sequence of other non-blank characters, separated with white space (spaces,
# tabs, <EOL>).  This can be changed with the 'iskeyword' option.  An empty line
# is also considered to be a word.

# A WORD consists of a sequence of non-blank characters, separated with white
# space.  An empty line is also considered to be a WORD.
local
}

# move to the start of current word or start of previous word,
# if the cursor is on the current word's first character (B,b)
function _vim_prev_word() {
local
}

# move to the end of current word or start of next word,
# if the cursor is on the current word's last character (E,e).
function _vim_end_word() {
local
}

function _vim_char_search() {
local
}

function _vim_change_char() {
  init_variable
  _vim_prompt "${red}r:${pink}${readline[*]}"
  READLINE_LINE="$first_before_point${VIM_PROMPT}$after_point_to_last"
  _bring_back_readline_color
}

function _vim_arg_digit() {
  local keys readline
 init_variable
  declare keys="$1"
  for (( i = 0; i < 3 ; i++ )); do
  _vim_prompt "${red}[args: ${keys}]${pink} ${readline[*]}";
   case $VIM_PROMPT in
      h )
        _vim_backward_char "${keys[*]}"
        return
        ;;
      l )
        _vim_forward_char "${keys[*]}"
        return
        ;;
      q )
        return
        ;;
     esac
     keys+=${VIM_PROMPT}
   done
}

function _vim_set_mark() {
  declare -Ag VIM_MARKERS
  init_variable
  _vim_prompt "${red}[mark]${pink} ${readline[*]}"
  VIM_MARKERS+=([$VIM_PROMPT]=$READLINE_POINT)
}


# marks should be linewise
# save curent line count, subtract to new linecount
# add to mark column
function _vim_goto_mark() {
  init_variable
  _vim_prompt "${red}[goto]${pink} ${readline[*]}"
  # marks stays at columns even after the readline has changed
  READLINE_POINT="${VIM_MARKERS["$VIM_PROMPT"]}"
}

function _vim_delete() { # x
  init_variable
  READLINE_LINE="${first_before_point}${after_point_to_last}"
 _bring_back_readline_color
}

function _vim_delete_to() {
  [[ "$#" -eq 0 ]] && {
    REGISTER_PLUS="$READLINE_LINE" \
      && READLINE_LINE=''
    _bring_back_readline_color
  }
}

function _vim_put() {
  # @note: i can highlight pasted content using colors
  # TODO: use %q printf format to reuse as shell input
  init_variable
  if [[ "$1" == 'P' ]]; then
   READLINE_LINE="${first_before_point}${REGISTER_PLUS}${point_to_last}"
  else
   [[ -z "$READLINE_LINE" ]] \
      && READLINE_LINE="$register_plus" \
      # TODO: should I move the cursor to last character of pasted content?
      #       I quite like it that the cursor stays from where it was.
    READLINE_LINE="$first_to_point$REGISTER_PLUS$after_point_to_last"
  fi
  _bring_back_readline_color
}

main && unset -f main
