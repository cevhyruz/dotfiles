#!/usr/bin/env bash

function enable_color_support() {

  if [[ $COLORTERM == gnome-* && $TERM == xterm ]] \
    && infocmp gnome-256color &> /dev/null; then
    export TERM="gnome-256color"
  elif infocmp xterm-256color &> /dev/null; then
    export TERM="xterm-256color"
  fi

}

function prompt_git() {

  local symbol='';
  local branchName='';

  # Check if the current directory is in a Git repository.
  if [ "$(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}")" == 0 ]; then

    # check if the current directory is in .git before running git checks
    if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

      # Ensure the index is up to date.
      git update-index --really-refresh -q &>/dev/null;

      # Check for uncommitted changes in the index.
      if ! git diff --quiet --ignore-submodules --cached; then
        symbol+='+';
      fi;

      # Check for unstaged changes.
      if ! git diff-files --quiet --ignore-submodules --; then
        symbol+='!';
      fi;

      # Check for untracked files.
      if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        symbol+='?';
      fi;

      # Check for stashed files.
      if git rev-parse --verify refs/stash &>/dev/null; then
        symbol+='∙';
      fi;

    fi;

    # Get the short symbolic ref.
    # If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
    # Otherwise, just give up.

    branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
       git rev-parse --short HEAD 2> /dev/null || \
       echo '(unknown)')";

    [ -n "${symbol}" ] && symbol=" ${symbol}";

    echo -e "${1}${branchName}${2}${symbol}";

  else
    return;
  fi;

}

function set_prompts() {

  local bold=""
  local reset=""

  local cyan=""
  local green=""
  local pink=""
  local yellow=""

  if tput setaf 1 &> /dev/null; then
    tput sgr0; # reset colors

    bold=$(tput bold);
    reset=$(tput sgr0);

    cyan=$(tput setaf 37)
    green=$(tput setaf 41)
    dimgrey=$(tput setaf 248)
    pink=$(tput setaf 216)
    yellow=$(tput setaf 178);
    red=$(tput setaf 203);

  fi

  # Change prompt indicator for different userlevel.
  if [[ "${USER}" == "root" ]]; then
    user_style="\\[#\\]";
  else
    user_style="\\[$\\]";
  fi;

  PS1="\\n\\[${bold}\\]"
  PS1+="\\[${green}\\]"
  PS1+="\\[${cyan}\\]\\W"                # Working directory
  PS1+="\$(prompt_git \"\\[${yellow}\\](\\[${red}\\]\" \"\\[${yellow}\\])\")";
  PS1+="\\[${reset}\\] \\[${user_style}\\] \\[${pink}\\]"

  export PS1

  PS2="\\[${green}\\]   ➜  "
  PS2+="\\[${pink}\\]"

  export PS2

  trap 'echo -ne "${dimgrey}"' DEBUG
}

function main() {
  enable_color_support
  set_prompts
}

main

# cleanup
unset -f enable_color_support
unset -f main
unset -f set_prompts
