#!/usr/bin/env bash

function enable_color_support() {
  if [[ $COLORTERM == gnome-* && $TERM == xterm ]] \
  && infocmp gnome-256color &> /dev/null; then
    export TERM="gnome-256color"
  elif infocmp xterm-256color &> /dev/null; then
    export TERM="xterm-256color"
  fi
}

function prompt_git() {
  # [!]  Don't break this function into smaller,  more specialized ones
  # as it will only pollute the global space and will result in a laggy
  # terminal shell. This function cannot be unset because it's called
  # every time the prompt string is shown.
  #
  # [?] Usage: prompt_git <branch-delimeter> <status-delimeter>
  local stat branch_name

  # Check if we're inside a git repo.
  ! command git rev-parse &> /dev/null \
  && return;

  # Check if inside the .git/ directory first before running status checks.
  if [ "$(command git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then
    # Ensure the index is up to date.
    command git update-index --really-refresh -q &> /dev/null;
    # Check for uncommitted changes in the index.
    if ! command git diff --quiet --ignore-submodules --cached; then
      stat+='+';
    fi;
    # Check for unstaged changes.
    if ! command git diff-files --quiet --ignore-submodules --; then
      stat+='!';
    fi;
    # Check for untracked files.
    # [!] Doesn't work inside `.git/` directory.
    if [ -n "$(command git ls-files --others --exclude-standard)" ]; then
      stat+='?';
    fi;
    # Check for stashed files.
    if command git rev-parse --verify refs/stash &>/dev/null; then
      stat+='⁕';
    fi;
  fi

  # Get the short symbolic ref.
  # If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
  # Otherwise, just give up.
  branch_name="$(command git symbolic-ref --quiet --short HEAD 2> /dev/null || \
      command git rev-parse --short HEAD 2> /dev/null || \
      echo 'unknown')";

  [ -n "${stat}" ] && stat="${stat}";
  echo -e "${1}${branch_name}${2} ${3}${stat}${4}";
}

function set_prompts() {
  local bold reset italic
  local cyan pink yellow green

  if tput setaf 1 &> /dev/null; then
    tput sgr0; # reset

    # attributes
    bold=$(tput bold);
    reset=$(tput sgr0);
    italic=$(tput sitm);

    cyan=$(tput setaf 37)
    dimgrey=$(tput setaf 248)
    pink=$(tput setaf 216)
    yellow=$(tput setaf 178);
    green=$(tput setaf 30);
    red=$(tput setaf 203);
    white=$(tput setaf 246);
  fi

  # ------------------------------------------------------------------
  # PS1 - the default propmt
  # ------------------------------------------------------------------
  PS1="\\n\\[${bold}\\]"
  PS1+="\\[${white}\\]"
  PS1+="\\[${cyan}\\]"
  PS1+=" \\W"
  PS1+="\$(prompt_git \"\\[${yellow}\\](\\[${red}\\]\" \"\\[${yellow}\\])\")"
  #                                    └───────> delimeter char <───────┘
  PS1+="\\[${reset}\\]"
  PS1+="\\[${reset}\\]"
  PS1+="\\[${italic}\\]"
  PS1+="\\[${green}\\]"
  PS1+="\\[${reset}\\]"
  PS1+="\\[${pink}\\]"
  PS1+=" \\n \\$ "

  # ------------------------------------------------------------------
  # PS2 - Continuation prompt
  # ------------------------------------------------------------------
  PS2="\\[${pink}\\] \\$  "

  trap 'echo -ne "${dimgrey}"' DEBUG
}

function main() {
  enable_color_support
  set_prompts

  # Cleanup.
  unset -f enable_color_support
  unset -f set_prompts
}

main && unset -f main

# vim:fdm=indent cc=75:
