#!/usr/bin/env bash

function _inside_git() {
  # Check if the current directory is in a Git repository.
  if [ "$(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}")" == 0 ]; then
    # Make sure we are not inside the .git/ directory.
    if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then
      return 0
    fi
  else
    return 1
  fi
}

function enable_color_support() {

  if [[ $COLORTERM == gnome-* && $TERM == xterm ]] \
    && infocmp gnome-256color &> /dev/null; then
    export TERM="gnome-256color"
  elif infocmp xterm-256color &> /dev/null; then
    export TERM="xterm-256color"
  fi

}

function prompt_git() {

  local symbol='';
  local branchName='';

  if _inside_git; then

      # Ensure the index is up to date.
      git update-index --really-refresh -q &>/dev/null;

      # Check for uncommitted changes in the index.
      if ! git diff --quiet --ignore-submodules --cached; then
        symbol+='+';
      fi;

      # Check for unstaged changes.
      if ! git diff-files --quiet --ignore-submodules --; then
        symbol+='!';
      fi;

      # Check for untracked files.
      if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        symbol+='?';
      fi;

      # Check for stashed files.
      if git rev-parse --verify refs/stash &>/dev/null; then
        symbol+='∙';
      fi;

    # Get the short symbolic ref.
    # If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
    # Otherwise, just give up.

    branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
       git rev-parse --short HEAD 2> /dev/null || \
       echo '(unknown)')";

    [ -n "${symbol}" ] && symbol=" ${symbol}";

    echo -e "${1}${branchName}${2}${symbol}";

  else
    return;
  fi;

}

function _git_commit() {

  local commit_message=""

  if _inside_git; then
    commit_message="$(git show --pretty=format:%s --no-patch HEAD)"
    echo -e "${commit_message}"
  else
    return;
  fi

}

function set_prompts() {

  local bold=""
  local reset=""
  local italic=""

  local cyan=""
  local pink=""
  local yellow=""
  local green=""

  if tput setaf 1 &> /dev/null; then
    tput sgr0; # reset colors

    bold=$(tput bold);
    reset=$(tput sgr0);
    italic=$(tput sitm);

    cyan=$(tput setaf 37)
    dimgrey=$(tput setaf 248)
    pink=$(tput setaf 216)
    yellow=$(tput setaf 178);
    green=$(tput setaf 30);
    red=$(tput setaf 203);
    white=$(tput setaf 246);

  fi


  PS1="\\n\\[${bold}\\]"
  PS1+=" \\[${white}\\]"
  PS1+="\\u"
  PS1+="\\[${cyan}\\] \\W:"                # Working directory
  PS1+="\$(prompt_git \"\\[${yellow}\\](\\[${red}\\]\" \"\\[${yellow}\\])\")";
  PS1+="\\[${reset}\\]"
  PS1+="\\n \\[${italic}\\]"
  PS1+="\\[${green}\\]"
  PS1+="\$(_git_commit \" \")"
  PS1+="\\[${reset}\\]"
  PS1+="\\[${pink}\\]"
  PS1+=" \\n\\$  "

  set PS1

  PS2="\\[${pink}\\] \\$  "

  export PS2

  trap 'echo -ne "${dimgrey}"' DEBUG
  printf '\033[?7l'   # Disable terminal wrapping.

}

function main() {
  enable_color_support
  set_prompts
}

main

# cleanup
unset -f enable_color_support
unset -f main
unset -f set_prompts
