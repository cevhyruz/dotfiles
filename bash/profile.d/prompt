#!/usr/bin/env bash

function _inside_git() {
  # Check if the current directory is in a Git repository.}}}
  if [ "$(git rev-parse --is-inside-work-tree &> /dev/null; echo "${?}")" == 0 ]; then
    # Make sure we are not inside the .git/ directory.
    if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then
      return 0
    fi
  else
    return 1
  fi
}

function _enable_color_support() {
  if [[ $COLORTERM == gnome-* && $TERM == xterm ]] \
    && infocmp gnome-256color &> /dev/null; then
    export TERM="gnome-256color"
  elif infocmp xterm-256color &> /dev/null; then
    export TERM="xterm-256color"
  fi
}

function prompt_git() {
  local symbol branch_name

  if _inside_git; then

    # Ensure the index is up to date.
    git update-index --really-refresh -q &>/dev/null;

    # Check for uncommitted changes in the index.
    if ! git diff --quiet --ignore-submodules --cached; then
      symbol+='+';
    fi;

    # Check for unstaged changes.
    if ! git diff-files --quiet --ignore-submodules --; then
      symbol+='!';
    fi;

    # Check for untracked files.
    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
      symbol+='?';
    fi;

    # Check for stashed files.
    if git rev-parse --verify refs/stash &>/dev/null; then
      symbol+='⁕';
    fi;

    # Get the short symbolic ref.
    # If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
    # Otherwise, just give up.
    branch_name=" $(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
        git rev-parse --short HEAD 2> /dev/null || \
        echo 'unknown') ";

    [ -n "${symbol}" ] && symbol=" ${symbol}";
    echo -e "${1}${branch_name}${2}${symbol}";
  else
    return;
  fi;
}

function git_commit() {
  local commit_message
  if _inside_git; then
    commit_message="$(git show --pretty=format:%s --no-patch HEAD 2> /dev/null)"
    if [ "$(git rev-parse HEAD &> /dev/null; echo "${?}")" == 0 ]; then
      echo -e "\\n ${commit_message}"
    fi
  else
    return;
  fi
}

function set_prompts() {
  local bold reset italic
  local cyan pink yellow green

  if tput setaf 1 &> /dev/null; then
    tput sgr0; # reset colors

    bold=$(tput bold);
    reset=$(tput sgr0);
    italic=$(tput sitm);

    cyan=$(tput setaf 37)
    dimgrey=$(tput setaf 248)
    pink=$(tput setaf 216)
    yellow=$(tput setaf 178);
    green=$(tput setaf 30);
    red=$(tput setaf 203);
    white=$(tput setaf 246);
  fi

  PS1="\\n\\[${bold}\\]"
  PS1+=" \\[${white}\\]"
  PS1+="\\u"
  PS1+="\\[${cyan}\\]:\\W"
  PS1+="\$(prompt_git \"\\[${yellow}\\](\\[${red}\\]\" \"\\[${yellow}\\])\")"
  PS1+="\\[${reset}\\]"
  PS1+="\\[${italic}\\]"
  PS1+="\\[${green}\\]"
  PS1+="\$(git_commit \" \")"
  PS1+="\\[${reset}\\]"
  PS1+="\\[${pink}\\]"
  PS1+=" \\n \\$  "

  PS2="\\[${pink}\\] \\$  "
  trap 'echo -ne "${dimgrey}"' DEBUG
}

function main() {
  _enable_color_support
  set_prompts
  unset -f _enable_color_support
  unset -f set_prompts
}

main && unset -f main
